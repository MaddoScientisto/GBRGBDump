@page "/printer"
@using System.Collections.ObjectModel
@using System.Diagnostics
@using GBTools.Graphics.Services
@inject HttpClient _client
@inject PrinterImageService PrinterImageService
@inject ISettingsService SettingsService

<Container Fluid>

    <Row>
        <h3>PicoPrinter</h3>
    </Row>
    <Row>
        @if (string.IsNullOrWhiteSpace(Model!.PrinterAddress))
        {
            <Alert Color="Color.Danger" Visible>
                <AlertDescription>No printer address specified, please add it to the settings</AlertDescription>
            </Alert>
        }
        <ErrorViewer ErrorText="@_errorText"></ErrorViewer>
    </Row>

    <Row>
        <Buttons Role="ButtonsRole.Toolbar">
            <Buttons Margin="Margin.Is2.FromEnd">
                <Button Clicked="ProcessGbPrinterData" Color="Color.Primary" Disabled="@CannotExecute" Loading="@IsProcessing"><Icon Name="IconName.Print"/> Get from GB Printer</Button>
                <Button Color="Color.Info"><Icon Name="IconName.HandPaper"/> Tear</Button>
                <Button Color="Color.Secondary" Clicked="SelectAll"><Icon Name="IconName.CheckDouble"/> Select All</Button>
            </Buttons>
            <Buttons>
                <Button Color="Color.Danger" Clicked="Delete"><Icon Name="IconName.Delete" /> Delete</Button>
            </Buttons>
            <Buttons Margin="Margin.Is2.OnX">
                <Button Color="Color.Primary">Average</Button>
                <Button Color="Color.Primary">RGB</Button>
            </Buttons>
        </Buttons>
        
    </Row>
    <Row>
        <div class="gallery">
            @foreach (var image in _images)
            {
                @* <Card>
                    <CardImage Source="@image.DataSource" Style="image-rendering: pixelated;" @onclick="() => OnPictureClick(image)"></CardImage>
                    <CardBody Padding="Padding.Is1">
                        <CardText>Image @image.Name</CardText>

                        <Button Size="Size.Small"
                                Margin="Margin.Is2.FromTop"
                                Padding="Padding.Is0" 
                                Color="Color.Primary" Outline><Icon Name="IconName.Download" /></Button>
                        <Button Size="Size.Small"
                                Margin="Margin.Is2.FromTop"
                                Padding="Padding.Is0" 
                                Color="Color.Danger" Outline><Icon Name="IconName.Delete" /></Button>
                    </CardBody>
                </Card> *@

                <div class="gallery-item">
                    <img @onclick="() => OnPictureClick(image)" src="@image.DataSource" alt="Image @image.Name" />
                    <div class="caption">@image.Name</div>
                    <div class="button-row">
                        <Check TValue="bool" @bind-Checked="@image.IsSelected"></Check>
                        <Button Size="Size.Small"
                                Margin="Margin.Is2.FromTop"
                                Padding="Padding.Is0"
                                Color="Color.Primary" Outline>
                            <Icon Name="IconName.Download"/>
                        </Button>
                        <Button Size="Size.Small"
                                Margin="Margin.Is2.FromTop"
                                Padding="Padding.Is0"
                                Color="Color.Danger"
                                @onclick="() => Delete(image)"
                                Outline>
                            <Icon Name="IconName.Delete"/>
                        </Button>
                    </div>
                </div>
            }
        </div>
        @*  <div class="gallery">
            @foreach (var image in _images)
            {
                @* <div class="gallery-item">
                    <img @onclick="() => OnPictureClick(image)" src="@image" alt="image caption"/>
                    <div class="caption">Name</div>
                    <div class="button-row">
                        <Button>test</Button>
                        <Button>test 2</Button>
                    </div>
                </div> *@
        @*}
        </div> *@

    </Row>
</Container>

<Modal @ref="modalRef">
    <ModalContent Centered>
        <ModalHeader>
            <ModalTitle>@ImagePreview.Name</ModalTitle>
            <CloseButton/>
        </ModalHeader>
        <ModalBody>
            <Card>
                <CardImage Source="@ImagePreview.DataSource" Style="image-rendering: pixelated;"></CardImage>
                <CardBody>
                    <Button Color="Color.Primary"><Icon Name="IconName.Download" /></Button>
                    <Button Color="Color.Danger"><Icon Name="IconName.Delete" /></Button>
                </CardBody>
            </Card>
        </ModalBody>
    </ModalContent>
</Modal>

<ConfirmationModal @ref="_confirmationModalRef" Title="Confirmation">
    <Content>
        @if (ImagePreview.IsValid)
        {
            <img src="@ImagePreview.DataSource"/>
        }
        <div>Confirm Operation</div>
    </Content>
</ConfirmationModal>

@code {
    ObservableCollection<GbImageContainer> _images = [];
    private bool IsProcessing { get; set; } = false;

    private string _errorText = String.Empty;

    private SettingsModel? Model { get; set; }

    private bool CannotExecute => IsProcessing || string.IsNullOrWhiteSpace(Model!.PrinterAddress);

    private Modal modalRef;

    private ConfirmationModal _confirmationModalRef;

    private GbImageContainer ImagePreview { get; set; } = new GbImageContainer();

    protected override void OnInitialized()
    {
        Model ??= SettingsService.LoadSettings() ?? new()
        {
            // Set defaults here
            ChannelOrder = ChannelOrder.Sequential,
            AverageType = AverageTypes.Normal
        };
    }

    private async Task<byte[]> ProcessDataAsync(string imageBinPath)
    {
        // Fetch the binary data from the provided path
        var res = await _client.GetAsync(imageBinPath);

        // Ensure the request was successful
        res.EnsureSuccessStatusCode();

        // Read the response body as a stream
        var resBodyStream = await res.Content.ReadAsStreamAsync();

        // Retrieve the response size (content length)
        var dataSize = res.Content.Headers.ContentLength ?? 0;

        // Read the stream into a byte array (equivalent to Uint8Array in JavaScript)
        byte[] resData;
        using var memoryStream = new MemoryStream();
        await resBodyStream.CopyToAsync(memoryStream);
        resData = memoryStream.ToArray();

        // Initialize processed_data as a new byte array, similar to Uint8Array in JavaScript
        //int bufferSize = (int)Math.Max(1024 * 1024, dataSize);
        //byte[] processedData = new byte[bufferSize];

        // You can now continue processing `resData` and `processedData` as needed

        return resData; // or perform further processing here and return as necessary
    }

    private async Task ProcessGbPrinterData()
    {
        IsProcessing = true;
        _errorText = string.Empty;

        try
        {
            var data = await ProcessDataAsync($"{Model!.PrinterAddress}/download");

            var processedData = await PrinterImageService.GetImages(data);

            var date = DateTime.Now;

            _images = new ObservableCollection<GbImageContainer>(processedData.Select((x, index) => new GbImageContainer()
            {
                Base64Png = x,
                Name = $"{date:s} {index}",
                Id = index
            }));
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            Debug.WriteLine(e);
            _errorText = e.ToString();
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private async Task OnPictureClick(GbImageContainer picture)
    {
        ImagePreview = picture;
        await modalRef.Show();
    }

    private void SelectAll()
    {

        if (_images.All(x => x.IsSelected))
        {
            foreach (var image in _images)
            {
                image.IsSelected = false;
            }

            return;
        }

        foreach (var image in _images)
        {
            image.IsSelected = true;
        }
    }

    private async Task Delete()
    {
        // Clear preview
        ImagePreview = new GbImageContainer();
        StateHasChanged();

        var confirmed = await _confirmationModalRef.ShowAsync();

        try
        {
            if (confirmed)
            {
                var itemsToRemove = _images.Where(x => x.IsSelected).ToList();

                foreach (var image in itemsToRemove)
                {
                    _images.Remove(image);
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            _errorText = e.ToString();
        }


    }

    private async Task Delete(GbImageContainer image)
    {
        try
        {
            ImagePreview = image;

            var confirmed = await _confirmationModalRef.ShowAsync();
            if (confirmed)
            {
                _images.Remove(image);
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            _errorText = e.ToString();
        }
        finally
        {
            ImagePreview = new GbImageContainer();
        }
    }


    public class GbImageContainer
    {
        public string Base64Png { get; set; } = string.Empty;

        public string DataSource => $"data:image/png;base64,{Base64Png}";

        public string Name { get; set; } = string.Empty;
        public int Id { get; set; }

        public bool IsSelected { get; set; } = false;

        public bool IsValid => !string.IsNullOrWhiteSpace(Base64Png);
    }

}