@page "/printer"

@inject HttpClient _client
@inject PrinterImageService PrinterImageService
@inject ISettingsService SettingsService
@inject ImageProcessingService ImageProcessingService

<Container Fluid>

    <Row>
        <h3>PicoPrinter</h3>
    </Row>
    <Row>
        @if (string.IsNullOrWhiteSpace(Model!.PrinterAddress))
        {
            <Alert Color="Color.Danger" Visible>
                <AlertDescription>No printer address specified, please add it to the settings</AlertDescription>
            </Alert>
        }
        <ErrorViewer ErrorText="@_errorText"></ErrorViewer>
    </Row>

    <Row>
        <Buttons Role="ButtonsRole.Toolbar">
            <Buttons Margin="Margin.Is2.FromEnd">
                <Button Clicked="ProcessGbPrinterData" Color="Color.Primary" Disabled="@CannotExecute" Loading="@IsProcessing"><Icon Name="IconName.Print"/> Get from GB Printer</Button>
                <Button Color="Color.Info" Clicked="Tear"><Icon Name="IconName.HandPaper"/> Tear</Button>
                @* <Button Color="Color.Secondary" Clicked="SelectAll"><Icon Name="IconName.CheckDouble"/> Select All</Button> *@
            </Buttons>
            @* <Buttons>
                <Button Color="Color.Danger" Clicked="Delete"><Icon Name="IconName.Delete" /> Delete</Button>
            </Buttons>
            <Buttons Margin="Margin.Is2.OnX">
                <Button Color="Color.Primary" Clicked="Average">Average</Button>
                <Button Color="Color.Primary" Clicked="RGBMerge">RGB</Button>
            </Buttons> *@
        </Buttons>
        
    </Row>
    <Row>
        <Gallery @ref="galleryRef" @bind-Images="_images"></Gallery>
    </Row>
</Container>



<ConfirmationModal @ref="_confirmationModalRef" Title="Confirmation">
    <Content>
        @if (ImagePreview.IsValid)
        {
            <img src="@ImagePreview.DataSource"/>
        }
        <div>Confirm Operation</div>
    </Content>
</ConfirmationModal>

@code {

    [Inject] IJSRuntime JSRuntime { get; set; }
    [Inject] INotificationService NotificationService { get; set; }
    [Inject] IMessageService MessageService { get; set; }

    ObservableCollection<GbImageContainer> _images = [];
    private bool IsProcessing { get; set; } = false;

    private string _errorText = String.Empty;

    private SettingsModel? Model { get; set; }

    private bool CannotExecute => IsProcessing || string.IsNullOrWhiteSpace(Model!.PrinterAddress);

    private Gallery galleryRef;

    private Modal modalRef;

    private ConfirmationModal _confirmationModalRef;

    private GbImageContainer ImagePreview { get; set; } = new GbImageContainer();

    protected override void OnInitialized()
    {
        Model ??= SettingsService.LoadSettings() ?? new()
        {
            // Set defaults here
            ChannelOrder = ChannelOrder.Sequential,
            AverageType = AverageTypes.Normal
        };
    }

    private async Task<byte[]> ProcessDataAsync(string imageBinPath)
    {
        // Fetch the binary data from the provided path
        var res = await _client.GetAsync(imageBinPath);

        // Ensure the request was successful
        res.EnsureSuccessStatusCode();

        // Read the response body as a stream
        var resBodyStream = await res.Content.ReadAsStreamAsync();

        // Retrieve the response size (content length)
        var dataSize = res.Content.Headers.ContentLength ?? 0;

        // Read the stream into a byte array (equivalent to Uint8Array in JavaScript)
        byte[] resData;
        using var memoryStream = new MemoryStream();
        await resBodyStream.CopyToAsync(memoryStream);
        resData = memoryStream.ToArray();

        // Initialize processed_data as a new byte array, similar to Uint8Array in JavaScript
        //int bufferSize = (int)Math.Max(1024 * 1024, dataSize);
        //byte[] processedData = new byte[bufferSize];

        // You can now continue processing `resData` and `processedData` as needed

        return resData; // or perform further processing here and return as necessary
    }

    private async Task ProcessGbPrinterData()
    {
        IsProcessing = true;
        _errorText = string.Empty;

        try
        {
            var data = await ProcessDataAsync($"{Model!.PrinterAddress}/download");

            var processedData = await PrinterImageService.GetImages(data);

            var date = DateTime.Now;

            _images = new ObservableCollection<GbImageContainer>(processedData.Select((x, index) => new GbImageContainer()
            {
                Base64Png = x,
                Name = $"{date:s} {index}",
                Id = index
            }));

            await NotificationService.Success("Images downloaded.");
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            Debug.WriteLine(e);
            await MessageService.Error(e.ToString());
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private async Task Tear()
    {
        _errorText = string.Empty;
        try
        {
            var confirmed = await _confirmationModalRef.ShowAsync();

            if (confirmed)
            {
                var res = await _client.GetAsync($"{Model!.PrinterAddress}/reset");

                res.EnsureSuccessStatusCode();

                var text = await res.Content.ReadAsStringAsync();

                // TODO: Deserialize JSON

                if (text != "ok")
                {
                    await NotificationService.Error("Error, could not tear.");
                    return;
                }

                await NotificationService.Success("Teared successfully!");
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            await MessageService.Error(e.ToString());
        }

    }
    
    // TODO: Move to its own class, maybe in common library
    public class GbImageContainer
    {
        public string Base64Png { get; set; } = string.Empty;

        public string DataSource => $"data:image/png;base64,{Base64Png}";

        public string Name { get; set; } = string.Empty;
        public int Id { get; set; }

        public bool IsSelected { get; set; } = false;

        public bool IsValid => !string.IsNullOrWhiteSpace(Base64Png);
    }
}